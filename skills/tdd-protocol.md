# TDD 実行規約（プロトコル）

変更を継続的に行うための、TDD（テスト駆動開発）の実行規約。

単体テストの目的は、プロジェクトの成長を止めないこと（回帰検知と変更容易性の両立）。

---

## 概要

このスキルは「どうテストを書くか（設計）」ではなく「どう進めるか（運用）」を扱います。

テスト設計（テスト種別、AAA、カバレッジ等）は `skills/testing.md` を参照してください。

---

## いつ使うか

- 仕様追加、バグ修正、リファクタリング、レガシー改修など「変更」が発生する作業全般
- テストが無い/弱いコードベースで、安全な変更の足場が必要なとき

## 使わない（使いにくい）とき

- 変更を伴わない説明・調査のみの依頼
- 実行環境がなくテストを走らせられず、かつ代替（手動検証/設計レビュー等）が明確に要求されているとき

---

## ゴール

1) 回帰を検知できる
2) リファクタリングに耐える（偽陽性を増やさない）
3) フィードバックを短いループで得る
4) 保守しやすい（読みやすい、壊れにくい）

---

## 原則・制約

- 仕様として要求されていない外部挙動は変更しない（テストで意図を固定する）
- Red のまま構造変更しない（Refactor は Green のときだけ）
- 実装詳細（private、内部データ構造、呼び出し回数など）への過度な結合を避ける
- 非決定性（乱数・時刻・並行性・I/O・外部API）を放置したまま安定したテストは書けない。必ず制御点を作る

---

## 必要な入力（不足時の扱い）

可能なら以下を受け取る:

- 目的: 追加/修正したい振る舞い（受け入れ条件）
- 対象（リポジトリ/ディレクトリ）、言語、テスト実行コマンド
- 互換性（壊してはいけない外部I/F）

不足がある場合は、仮定を明示し、作業継続に必要なら質問して止まる（仕様を創作しない）。

---

## 成果物

- 追加/更新したテストコード（目的を示す最小限）
- プロダクションコードの変更（Green に必要十分）
- 実行したテストコマンドと結果（何を確認できたか）

---

## ワークフロー

### 0. 足場づくり（特にレガシー）

- テストが無い/薄い場合は、まず粗くても動く自動テストを 1 本置く（Happy Path でもよい）
- 実装から距離を取れる「観測できる境界」を探す（公開API、入出力境界、リクエスト/レスポンスなど）
- テストが不安定なら、先に非決定性の制御（Seam）を作る（後述）

### 1. TDD サイクル（Red → Green → Refactor）

1) 目標を小さく分割し、TODO（チェックリスト）にする
2) 1つだけ選び、失敗するテスト（Red）を書く
3) テストを実行し、失敗を確認する（Red の根拠を得る）
4) 目的を満たす最小の実装を加える
5) 全テスト成功（Green）
6) テストが通ったままリファクタリング（Refactor）
7) 繰り返す

### 2. テスト設計の最低限ルール（壊れにくさ優先）

- まず「観測可能な振る舞い」を Assert する（戻り値、公開APIの結果、永続化後の状態、外部に出るメッセージ等）
- テスト名は「振る舞い」を表現する（実装詳細・関数名直結を避ける）
- AAA（Arrange/Act/Assert）で読みやすく書く（詳細は `skills/testing.md`）

### 3. 非決定性の制御（Seam / Humble Object）

テストを壊しやすくする要素:

- 乱数、時刻、UUID、並行、ネットワーク、ファイル、環境変数、グローバル状態

対処:

- 接合部（Seam）を作り、外から差し替え可能にする（引数/DI/環境オブジェクト）
  - 例: `now()`, `uuid()`, `nextIndex()`, `httpClient` を注入
- テストでは固定値やフェイク実装を渡し、決定性を担保する
- 詳細（I/Oやフレームワーク依存）は薄く切り出し、テスト可能範囲を広く取る（Humble Object）

### 4. レガシー改修戦術（Extract vs Sprout）

- Extract: 既存コードに「粗い保護テスト」を置き、Green を保ちながらロジックを外へ引き剥がす
- Sprout: 既存へ深く触れず、新規部分だけをテスト駆動で育てる（境界で接続）

判断基準:

- 既存の外部挙動を保護できる最小テストが置けるなら Extract
- 置けない/危険/時間制約が強いなら Sprout を優先し、影響範囲を限定する

### 5. ドメインモデル分離（詳細から引き剥がす）

- “詳細”（フレームワーク/SDK/I/O）と“コアロジック”を分ける
- Plain なモデルに寄せると、単体テストが安定しやすい

段階的移行:

1) モデルクラスを新規に作り、モデルは TDD で育てる
2) 既存ハンドラからロジックをモデルへ移す（既存の粗粒度テストは Green 維持）
3) 状態は dump/restore 等で受け渡し、フレームワーク依存を減らす
4) 最終的にモデルが状態遷移を判断し、ハンドラ側の条件分岐を削る

### 6. 「事実」と「情報」を分ける（安定化）

- 永続化/状態として保持するのは “事実（データ）” を基本にする
- “情報” は事実から計算で導出する
- テストは「事実の入力 → 情報の算出」が一貫することを確認する

---

## チェックリスト

### Pre-flight（着手前）

- [ ] 目的（受け入れ条件）が 1 文で言える
- [ ] テスト実行コマンドが分かる（不明なら質問する）
- [ ] 影響範囲（壊してはいけない外部I/F）が分かる

### Per-cycle（各 TDD サイクル）

- [ ] Red: 失敗するテストが「振る舞い」を表している
- [ ] Green: 最小の変更で通した
- [ ] Refactor: Green のまま重複/責務/命名を整えた

### Before-submit（提出前）

- [ ] 全テストが安定して Green（フレークがない）
- [ ] テストが実装詳細に過度に依存していない
- [ ] 非決定性が注入/固定化されている

---

## ミニ例

### 例1: ランダム性のため期待値が揺れる

- 症状: テストの期待値が乱数で変わる
- 対処: `nextIndex()` を引数/DI で注入し、テストでは固定値を返す

### 例2: ハンドラにロジックが密集して保守が難しい

- 症状: 条件分岐が増え続け、仕様追加で破綻しやすい
- 対処: ドメインモデル（例: `Session`）を作り、モデルは TDD で開発し、ハンドラは I/F 変換に寄せる

### 例3: “情報” を状態に持っていて不整合が出る

- 症状: スコアや判定が複数箇所で更新され矛盾する
- 対処: 事実（試行ログ）を蓄積し、スコア等は導出に統一する

---

## 関連ファイル

- `skills/testing.md` - テスト設計（種別/AAA/命名/カバレッジ）
- `skills/error-handling.md` - エラーハンドリング（異常系テスト）
- `skills/estimation.md` - 見積もり（テスト計画セクション）
- `.agent/rules/dod.md` - Definition of Done（テスト要求）
- `.agent/commands/impl.md` - 実装フロー（テスト計画）
